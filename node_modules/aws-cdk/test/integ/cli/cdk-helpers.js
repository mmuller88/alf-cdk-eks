"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rememberToDeleteBucket = exports.shell = exports.cleanup = exports.deleteableStacks = exports.prepareAppFixture = exports.cloneDirectory = exports.fullStackName = exports.cdk = exports.cdkDestroy = exports.cdkDeploy = exports.log = exports.STACK_NAME_PREFIX = exports.INTEG_TEST_DIR = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const aws_helpers_1 = require("./aws-helpers");
exports.INTEG_TEST_DIR = path.join(os.tmpdir(), 'cdk-integ-test2');
exports.STACK_NAME_PREFIX = process.env.STACK_NAME_PREFIX || (() => {
    // Make the stack names unique based on the codebuild project name
    // (if it exists). This prevents multiple codebuild projects stomping
    // on each other's stacks and failing them.
    //
    // The get codebuild project name from the ID: PROJECT_NAME:1238a83
    if (process.env.CODEBUILD_BUILD_ID) {
        return process.env.CODEBUILD_BUILD_ID.split(':')[0];
    }
    if (process.env.IS_CANARY === 'true') {
        return 'cdk-toolkit-canary';
    }
    return 'cdk-toolkit-integration';
})();
function log(x) {
    process.stderr.write(x + '\n');
}
exports.log = log;
async function cdkDeploy(stackNames, options = {}) {
    var _a, _b;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    const neverRequireApproval = (_a = options.neverRequireApproval) !== null && _a !== void 0 ? _a : true;
    return await cdk(['deploy',
        ...(neverRequireApproval ? ['--require-approval=never'] : []), // Default to no approval in an unattended test
        ...((_b = options.options) !== null && _b !== void 0 ? _b : []), ...fullStackName(stackNames)], options);
}
exports.cdkDeploy = cdkDeploy;
async function cdkDestroy(stackNames, options = {}) {
    var _a;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    return await cdk(['destroy',
        '-f', // We never want a prompt in an unattended test
        ...((_a = options.options) !== null && _a !== void 0 ? _a : []), ...fullStackName(stackNames)], options);
}
exports.cdkDestroy = cdkDestroy;
async function cdk(args, options = {}) {
    return await shell(['cdk', ...args], {
        cwd: exports.INTEG_TEST_DIR,
        ...options,
        modEnv: {
            AWS_REGION: (await aws_helpers_1.testEnv()).region,
            AWS_DEFAULT_REGION: (await aws_helpers_1.testEnv()).region,
            STACK_NAME_PREFIX: exports.STACK_NAME_PREFIX,
            ...options.modEnv,
        },
    });
}
exports.cdk = cdk;
function fullStackName(stackNames) {
    if (typeof stackNames === 'string') {
        return `${exports.STACK_NAME_PREFIX}-${stackNames}`;
    }
    else {
        return stackNames.map(s => `${exports.STACK_NAME_PREFIX}-${s}`);
    }
}
exports.fullStackName = fullStackName;
/**
 * Prepare a target dir byreplicating a source directory
 */
async function cloneDirectory(source, target) {
    await shell(['rm', '-rf', target]);
    await shell(['mkdir', '-p', target]);
    await shell(['cp', '-R', source + '/*', target]);
}
exports.cloneDirectory = cloneDirectory;
/**
 * Prepare the app fixture
 *
 * If this is done in the main test script, it will be skipped
 * in the subprocess scripts since the app fixture can just be reused.
 */
async function prepareAppFixture() {
    await cloneDirectory(path.join(__dirname, 'app'), exports.INTEG_TEST_DIR);
    await shell(['npm', 'install',
        '@aws-cdk/core',
        '@aws-cdk/aws-sns',
        '@aws-cdk/aws-iam',
        '@aws-cdk/aws-lambda',
        '@aws-cdk/aws-ssm',
        '@aws-cdk/aws-ecr-assets',
        '@aws-cdk/aws-cloudformation',
        '@aws-cdk/aws-ec2'], {
        cwd: exports.INTEG_TEST_DIR,
    });
}
exports.prepareAppFixture = prepareAppFixture;
/**
 * Return the stacks starting with our testing prefix that should be deleted
 */
async function deleteableStacks(prefix) {
    var _a;
    const statusFilter = [
        'CREATE_IN_PROGRESS', 'CREATE_FAILED', 'CREATE_COMPLETE',
        'ROLLBACK_IN_PROGRESS', 'ROLLBACK_FAILED', 'ROLLBACK_COMPLETE',
        'DELETE_FAILED',
        'UPDATE_IN_PROGRESS', 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_COMPLETE', 'UPDATE_ROLLBACK_IN_PROGRESS',
        'UPDATE_ROLLBACK_FAILED',
        'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_ROLLBACK_COMPLETE', 'REVIEW_IN_PROGRESS',
        'IMPORT_IN_PROGRESS', 'IMPORT_COMPLETE',
        'IMPORT_ROLLBACK_IN_PROGRESS', 'IMPORT_ROLLBACK_FAILED',
        'IMPORT_ROLLBACK_COMPLETE',
    ];
    const response = await aws_helpers_1.cloudFormation('describeStacks', {});
    return ((_a = response.Stacks) !== null && _a !== void 0 ? _a : [])
        .filter(s => s.StackName.startsWith(prefix))
        .filter(s => statusFilter.includes(s.StackStatus))
        .filter(s => s.RootId === undefined); // Only delete parent stacks. Nested stacks are deleted in the process
}
exports.deleteableStacks = deleteableStacks;
/**
 * Cleanup leftover stacks and buckets
 */
async function cleanup() {
    const stacksToDelete = await deleteableStacks(exports.STACK_NAME_PREFIX);
    // Bootstrap stacks have buckets that need to be cleaned
    const bucketNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('BucketName', stack)).filter(defined);
    await Promise.all(bucketNames.map(aws_helpers_1.emptyBucket));
    // Bootstrap stacks have ECR repositories with images which should be deleted
    const imageRepositoryNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('ImageRepositoryName', stack)).filter(defined);
    await Promise.all(imageRepositoryNames.map(aws_helpers_1.deleteImageRepository));
    await aws_helpers_1.deleteStacks(...stacksToDelete.map(s => s.StackName));
    // We might have leaked some buckets by upgrading the bootstrap stack. Be
    // sure to clean everything.
    for (const bucket of bucketsToDelete) {
        await aws_helpers_1.deleteBucket(bucket);
    }
    bucketsToDelete = [];
}
exports.cleanup = cleanup;
/**
 * A shell command that does what you want
 *
 * Is platform-aware, handles errors nicely.
 */
async function shell(command, options = {}) {
    var _a;
    if (options.modEnv && options.env) {
        throw new Error('Use either env or modEnv but not both');
    }
    log(`ðŸ’» ${command.join(' ')}`);
    const env = (_a = options.env) !== null && _a !== void 0 ? _a : (options.modEnv ? { ...process.env, ...options.modEnv } : undefined);
    const child = child_process.spawn(command[0], command.slice(1), {
        ...options,
        env,
        // Need this for Windows where we want .cmd and .bat to be found as well.
        shell: true,
        stdio: ['ignore', 'pipe', 'pipe'],
    });
    return new Promise((resolve, reject) => {
        const stdout = new Array();
        const stderr = new Array();
        child.stdout.on('data', chunk => {
            process.stdout.write(chunk);
            stdout.push(chunk);
        });
        child.stderr.on('data', chunk => {
            var _a;
            process.stderr.write(chunk);
            if ((_a = options.captureStderr) !== null && _a !== void 0 ? _a : true) {
                stderr.push(chunk);
            }
        });
        child.once('error', reject);
        child.once('close', code => {
            if (code === 0 || options.allowErrExit) {
                resolve((Buffer.concat(stdout).toString('utf-8') + Buffer.concat(stderr).toString('utf-8')).trim());
            }
            else {
                reject(new Error(`'${command.join(' ')}' exited with error code ${code}: ${Buffer.concat(stderr).toString('utf-8').trim()}`));
            }
        });
    });
}
exports.shell = shell;
let bucketsToDelete = new Array();
/**
 * Append this to the list of buckets to potentially delete
 *
 * At the end of a test, we clean up buckets that may not have gotten destroyed
 * (for whatever reason).
 */
function rememberToDeleteBucket(bucketName) {
    bucketsToDelete.push(bucketName);
}
exports.rememberToDeleteBucket = rememberToDeleteBucket;
function defined(x) {
    return x !== undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLWhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjZGstaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwrQ0FBeUk7QUFFNUgsUUFBQSxjQUFjLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztBQUUzRCxRQUFBLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFDdEUsa0VBQWtFO0lBQ2xFLHFFQUFxRTtJQUNyRSwyQ0FBMkM7SUFDM0MsRUFBRTtJQUNGLG1FQUFtRTtJQUNuRSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEVBQUU7UUFBRSxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQUU7SUFDNUYsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsS0FBSyxNQUFNLEVBQUU7UUFBRSxPQUFPLG9CQUFvQixDQUFDO0tBQUU7SUFDdEUsT0FBTyx5QkFBeUIsQ0FBQztBQUNuQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBNEJMLFNBQWdCLEdBQUcsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRkQsa0JBRUM7QUFFTSxLQUFLLFVBQVUsU0FBUyxDQUFDLFVBQTZCLEVBQUUsVUFBeUIsRUFBRTs7SUFDeEYsVUFBVSxHQUFHLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBRXhFLE1BQU0sb0JBQW9CLFNB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QUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDekIsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3RDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUNyRztpQkFBTTtnQkFDTCxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsSUFBSSxLQUFLLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQy9IO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUEzQ0Qsc0JBMkNDO0FBRUQsSUFBSSxlQUFlLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztBQUUxQzs7Ozs7R0FLRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLFVBQWtCO0lBQ3ZELGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUZELHdEQUVDO0FBRUQsU0FBUyxPQUFPLENBQUksQ0FBSTtJQUN0QixPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDekIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgY2xvdWRGb3JtYXRpb24sIGRlbGV0ZUJ1Y2tldCwgZGVsZXRlSW1hZ2VSZXBvc2l0b3J5LCBkZWxldGVTdGFja3MsIGVtcHR5QnVja2V0LCBvdXRwdXRGcm9tU3RhY2ssIHRlc3RFbnYgfSBmcm9tICcuL2F3cy1oZWxwZXJzJztcblxuZXhwb3J0IGNvbnN0IElOVEVHX1RFU1RfRElSID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrLWludGVnLXRlc3QyJyk7XG5cbmV4cG9ydCBjb25zdCBTVEFDS19OQU1FX1BSRUZJWCA9IHByb2Nlc3MuZW52LlNUQUNLX05BTUVfUFJFRklYIHx8ICgoKSA9PiB7XG4gIC8vIE1ha2UgdGhlIHN0YWNrIG5hbWVzIHVuaXF1ZSBiYXNlZCBvbiB0aGUgY29kZWJ1aWxkIHByb2plY3QgbmFtZVxuICAvLyAoaWYgaXQgZXhpc3RzKS4gVGhpcyBwcmV2ZW50cyBtdWx0aXBsZSBjb2RlYnVpbGQgcHJvamVjdHMgc3RvbXBpbmdcbiAgLy8gb24gZWFjaCBvdGhlcidzIHN0YWNrcyBhbmQgZmFpbGluZyB0aGVtLlxuICAvL1xuICAvLyBUaGUgZ2V0IGNvZGVidWlsZCBwcm9qZWN0IG5hbWUgZnJvbSB0aGUgSUQ6IFBST0pFQ1RfTkFNRToxMjM4YTgzXG4gIGlmIChwcm9jZXNzLmVudi5DT0RFQlVJTERfQlVJTERfSUQpIHsgcmV0dXJuIHByb2Nlc3MuZW52LkNPREVCVUlMRF9CVUlMRF9JRC5zcGxpdCgnOicpWzBdOyB9XG4gIGlmIChwcm9jZXNzLmVudi5JU19DQU5BUlkgPT09ICd0cnVlJykgeyByZXR1cm4gJ2Nkay10b29sa2l0LWNhbmFyeSc7IH1cbiAgcmV0dXJuICdjZGstdG9vbGtpdC1pbnRlZ3JhdGlvbic7XG59KSgpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsT3B0aW9ucyBleHRlbmRzIGNoaWxkX3Byb2Nlc3MuU3Bhd25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgdG8gYWRkIHRvICdlbnYnXG4gICAqL1xuICBtb2RFbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBEb24ndCBmYWlsIHdoZW4gZXhpdGluZyB3aXRoIGFuIGVycm9yXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd0VyckV4aXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGNhcHR1cmUgc3RkZXJyXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNhcHR1cmVTdGRlcnI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENka0NsaU9wdGlvbnMgZXh0ZW5kcyBTaGVsbE9wdGlvbnMge1xuICBvcHRpb25zPzogc3RyaW5nW107XG4gIG5ldmVyUmVxdWlyZUFwcHJvdmFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyh4OiBzdHJpbmcpIHtcbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoeCArICdcXG4nKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNka0RlcGxveShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHN0YWNrTmFtZXMgPSB0eXBlb2Ygc3RhY2tOYW1lcyA9PT0gJ3N0cmluZycgPyBbc3RhY2tOYW1lc10gOiBzdGFja05hbWVzO1xuXG4gIGNvbnN0IG5ldmVyUmVxdWlyZUFwcHJvdmFsID0gb3B0aW9ucy5uZXZlclJlcXVpcmVBcHByb3ZhbCA/PyB0cnVlO1xuXG4gIHJldHVybiBhd2FpdCBjZGsoWydkZXBsb3knLFxuICAgIC4uLihuZXZlclJlcXVpcmVBcHByb3ZhbCA/IFsnLS1yZXF1aXJlLWFwcHJvdmFsPW5ldmVyJ10gOiBbXSksIC8vIERlZmF1bHQgdG8gbm8gYXBwcm92YWwgaW4gYW4gdW5hdHRlbmRlZCB0ZXN0XG4gICAgLi4uKG9wdGlvbnMub3B0aW9ucyA/PyBbXSksXG4gICAgLi4uZnVsbFN0YWNrTmFtZShzdGFja05hbWVzKV0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2RrRGVzdHJveShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHN0YWNrTmFtZXMgPSB0eXBlb2Ygc3RhY2tOYW1lcyA9PT0gJ3N0cmluZycgPyBbc3RhY2tOYW1lc10gOiBzdGFja05hbWVzO1xuXG4gIHJldHVybiBhd2FpdCBjZGsoWydkZXN0cm95JyxcbiAgICAnLWYnLCAvLyBXZSBuZXZlciB3YW50IGEgcHJvbXB0IGluIGFuIHVuYXR0ZW5kZWQgdGVzdFxuICAgIC4uLihvcHRpb25zLm9wdGlvbnMgPz8gW10pLFxuICAgIC4uLmZ1bGxTdGFja05hbWUoc3RhY2tOYW1lcyldLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNkayhhcmdzOiBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBzaGVsbChbJ2NkaycsIC4uLmFyZ3NdLCB7XG4gICAgY3dkOiBJTlRFR19URVNUX0RJUixcbiAgICAuLi5vcHRpb25zLFxuICAgIG1vZEVudjoge1xuICAgICAgQVdTX1JFR0lPTjogKGF3YWl0IHRlc3RFbnYoKSkucmVnaW9uLFxuICAgICAgQVdTX0RFRkFVTFRfUkVHSU9OOiAoYXdhaXQgdGVzdEVudigpKS5yZWdpb24sXG4gICAgICBTVEFDS19OQU1FX1BSRUZJWCxcbiAgICAgIC4uLm9wdGlvbnMubW9kRW52LFxuICAgIH0sXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVsbFN0YWNrTmFtZShzdGFja05hbWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBmdWxsU3RhY2tOYW1lKHN0YWNrTmFtZXM6IHN0cmluZ1tdKTogc3RyaW5nW107XG5leHBvcnQgZnVuY3Rpb24gZnVsbFN0YWNrTmFtZShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHN0cmluZyB8IHN0cmluZ1tdIHtcbiAgaWYgKHR5cGVvZiBzdGFja05hbWVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBgJHtTVEFDS19OQU1FX1BSRUZJWH0tJHtzdGFja05hbWVzfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YWNrTmFtZXMubWFwKHMgPT4gYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LSR7c31gKTtcbiAgfVxufVxuXG4vKipcbiAqIFByZXBhcmUgYSB0YXJnZXQgZGlyIGJ5cmVwbGljYXRpbmcgYSBzb3VyY2UgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9uZURpcmVjdG9yeShzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpIHtcbiAgYXdhaXQgc2hlbGwoWydybScsICctcmYnLCB0YXJnZXRdKTtcbiAgYXdhaXQgc2hlbGwoWydta2RpcicsICctcCcsIHRhcmdldF0pO1xuICBhd2FpdCBzaGVsbChbJ2NwJywgJy1SJywgc291cmNlICsgJy8qJywgdGFyZ2V0XSk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgYXBwIGZpeHR1cmVcbiAqXG4gKiBJZiB0aGlzIGlzIGRvbmUgaW4gdGhlIG1haW4gdGVzdCBzY3JpcHQsIGl0IHdpbGwgYmUgc2tpcHBlZFxuICogaW4gdGhlIHN1YnByb2Nlc3Mgc2NyaXB0cyBzaW5jZSB0aGUgYXBwIGZpeHR1cmUgY2FuIGp1c3QgYmUgcmV1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUFwcEZpeHR1cmUoKSB7XG4gIGF3YWl0IGNsb25lRGlyZWN0b3J5KHBhdGguam9pbihfX2Rpcm5hbWUsICdhcHAnKSwgSU5URUdfVEVTVF9ESVIpO1xuXG4gIGF3YWl0IHNoZWxsKFsnbnBtJywgJ2luc3RhbGwnLFxuICAgICdAYXdzLWNkay9jb3JlJyxcbiAgICAnQGF3cy1jZGsvYXdzLXNucycsXG4gICAgJ0Bhd3MtY2RrL2F3cy1pYW0nLFxuICAgICdAYXdzLWNkay9hd3MtbGFtYmRhJyxcbiAgICAnQGF3cy1jZGsvYXdzLXNzbScsXG4gICAgJ0Bhd3MtY2RrL2F3cy1lY3ItYXNzZXRzJyxcbiAgICAnQGF3cy1jZGsvYXdzLWNsb3VkZm9ybWF0aW9uJyxcbiAgICAnQGF3cy1jZGsvYXdzLWVjMiddLCB7XG4gICAgY3dkOiBJTlRFR19URVNUX0RJUixcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdGFja3Mgc3RhcnRpbmcgd2l0aCBvdXIgdGVzdGluZyBwcmVmaXggdGhhdCBzaG91bGQgYmUgZGVsZXRlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlYWJsZVN0YWNrcyhwcmVmaXg6IHN0cmluZyk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrW10+IHtcbiAgY29uc3Qgc3RhdHVzRmlsdGVyID0gW1xuICAgICdDUkVBVEVfSU5fUFJPR1JFU1MnLCAnQ1JFQVRFX0ZBSUxFRCcsICdDUkVBVEVfQ09NUExFVEUnLFxuICAgICdST0xMQkFDS19JTl9QUk9HUkVTUycsICdST0xMQkFDS19GQUlMRUQnLCAnUk9MTEJBQ0tfQ09NUExFVEUnLFxuICAgICdERUxFVEVfRkFJTEVEJyxcbiAgICAnVVBEQVRFX0lOX1BST0dSRVNTJywgJ1VQREFURV9DT01QTEVURV9DTEVBTlVQX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX0NPTVBMRVRFJywgJ1VQREFURV9ST0xMQkFDS19JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19GQUlMRUQnLFxuICAgICdVUERBVEVfUk9MTEJBQ0tfQ09NUExFVEVfQ0xFQU5VUF9JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19DT01QTEVURScsICdSRVZJRVdfSU5fUFJPR1JFU1MnLFxuICAgICdJTVBPUlRfSU5fUFJPR1JFU1MnLCAnSU1QT1JUX0NPTVBMRVRFJyxcbiAgICAnSU1QT1JUX1JPTExCQUNLX0lOX1BST0dSRVNTJywgJ0lNUE9SVF9ST0xMQkFDS19GQUlMRUQnLFxuICAgICdJTVBPUlRfUk9MTEJBQ0tfQ09NUExFVEUnLFxuICBdO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywge30pO1xuXG4gIHJldHVybiAocmVzcG9uc2UuU3RhY2tzID8/IFtdKVxuICAgIC5maWx0ZXIocyA9PiBzLlN0YWNrTmFtZS5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgLmZpbHRlcihzID0+IHN0YXR1c0ZpbHRlci5pbmNsdWRlcyhzLlN0YWNrU3RhdHVzKSlcbiAgICAuZmlsdGVyKHMgPT4gcy5Sb290SWQgPT09IHVuZGVmaW5lZCk7IC8vIE9ubHkgZGVsZXRlIHBhcmVudCBzdGFja3MuIE5lc3RlZCBzdGFja3MgYXJlIGRlbGV0ZWQgaW4gdGhlIHByb2Nlc3Ncbn1cblxuLyoqXG4gKiBDbGVhbnVwIGxlZnRvdmVyIHN0YWNrcyBhbmQgYnVja2V0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgc3RhY2tzVG9EZWxldGUgPSBhd2FpdCBkZWxldGVhYmxlU3RhY2tzKFNUQUNLX05BTUVfUFJFRklYKTtcblxuICAvLyBCb290c3RyYXAgc3RhY2tzIGhhdmUgYnVja2V0cyB0aGF0IG5lZWQgdG8gYmUgY2xlYW5lZFxuICBjb25zdCBidWNrZXROYW1lcyA9IHN0YWNrc1RvRGVsZXRlLm1hcChzdGFjayA9PiBvdXRwdXRGcm9tU3RhY2soJ0J1Y2tldE5hbWUnLCBzdGFjaykpLmZpbHRlcihkZWZpbmVkKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoYnVja2V0TmFtZXMubWFwKGVtcHR5QnVja2V0KSk7XG5cbiAgLy8gQm9vdHN0cmFwIHN0YWNrcyBoYXZlIEVDUiByZXBvc2l0b3JpZXMgd2l0aCBpbWFnZXMgd2hpY2ggc2hvdWxkIGJlIGRlbGV0ZWRcbiAgY29uc3QgaW1hZ2VSZXBvc2l0b3J5TmFtZXMgPSBzdGFja3NUb0RlbGV0ZS5tYXAoc3RhY2sgPT4gb3V0cHV0RnJvbVN0YWNrKCdJbWFnZVJlcG9zaXRvcnlOYW1lJywgc3RhY2spKS5maWx0ZXIoZGVmaW5lZCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKGltYWdlUmVwb3NpdG9yeU5hbWVzLm1hcChkZWxldGVJbWFnZVJlcG9zaXRvcnkpKTtcblxuICBhd2FpdCBkZWxldGVTdGFja3MoLi4uc3RhY2tzVG9EZWxldGUubWFwKHMgPT4gcy5TdGFja05hbWUpKTtcblxuICAvLyBXZSBtaWdodCBoYXZlIGxlYWtlZCBzb21lIGJ1Y2tldHMgYnkgdXBncmFkaW5nIHRoZSBib290c3RyYXAgc3RhY2suIEJlXG4gIC8vIHN1cmUgdG8gY2xlYW4gZXZlcnl0aGluZy5cbiAgZm9yIChjb25zdCBidWNrZXQgb2YgYnVja2V0c1RvRGVsZXRlKSB7XG4gICAgYXdhaXQgZGVsZXRlQnVja2V0KGJ1Y2tldCk7XG4gIH1cbiAgYnVja2V0c1RvRGVsZXRlID0gW107XG59XG5cbi8qKlxuICogQSBzaGVsbCBjb21tYW5kIHRoYXQgZG9lcyB3aGF0IHlvdSB3YW50XG4gKlxuICogSXMgcGxhdGZvcm0tYXdhcmUsIGhhbmRsZXMgZXJyb3JzIG5pY2VseS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNoZWxsKGNvbW1hbmQ6IHN0cmluZ1tdLCBvcHRpb25zOiBTaGVsbE9wdGlvbnMgPSB7fSk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmIChvcHRpb25zLm1vZEVudiAmJiBvcHRpb25zLmVudikge1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlIGVpdGhlciBlbnYgb3IgbW9kRW52IGJ1dCBub3QgYm90aCcpO1xuICB9XG5cbiAgbG9nKGDwn5K7ICR7Y29tbWFuZC5qb2luKCcgJyl9YCk7XG5cbiAgY29uc3QgZW52ID0gb3B0aW9ucy5lbnYgPz8gKG9wdGlvbnMubW9kRW52ID8gey4uLnByb2Nlc3MuZW52LCAuLi5vcHRpb25zLm1vZEVudn0gOiB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGNoaWxkID0gY2hpbGRfcHJvY2Vzcy5zcGF3bihjb21tYW5kWzBdLCBjb21tYW5kLnNsaWNlKDEpLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBlbnYsXG4gICAgLy8gTmVlZCB0aGlzIGZvciBXaW5kb3dzIHdoZXJlIHdlIHdhbnQgLmNtZCBhbmQgLmJhdCB0byBiZSBmb3VuZCBhcyB3ZWxsLlxuICAgIHNoZWxsOiB0cnVlLFxuICAgIHN0ZGlvOiBbICdpZ25vcmUnLCAncGlwZScsICdwaXBlJyBdLFxuICB9KTtcblxuICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3Rkb3V0ID0gbmV3IEFycmF5PEJ1ZmZlcj4oKTtcbiAgICBjb25zdCBzdGRlcnIgPSBuZXcgQXJyYXk8QnVmZmVyPigpO1xuXG4gICAgY2hpbGQuc3Rkb3V0IS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNodW5rKTtcbiAgICAgIHN0ZG91dC5wdXNoKGNodW5rKTtcbiAgICB9KTtcblxuICAgIGNoaWxkLnN0ZGVyciEub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShjaHVuayk7XG4gICAgICBpZiAob3B0aW9ucy5jYXB0dXJlU3RkZXJyID8/IHRydWUpIHtcbiAgICAgICAgc3RkZXJyLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2hpbGQub25jZSgnZXJyb3InLCByZWplY3QpO1xuXG4gICAgY2hpbGQub25jZSgnY2xvc2UnLCBjb2RlID0+IHtcbiAgICAgIGlmIChjb2RlID09PSAwIHx8IG9wdGlvbnMuYWxsb3dFcnJFeGl0KSB7XG4gICAgICAgIHJlc29sdmUoKEJ1ZmZlci5jb25jYXQoc3Rkb3V0KS50b1N0cmluZygndXRmLTgnKSArIEJ1ZmZlci5jb25jYXQoc3RkZXJyKS50b1N0cmluZygndXRmLTgnKSkudHJpbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYCcke2NvbW1hbmQuam9pbignICcpfScgZXhpdGVkIHdpdGggZXJyb3IgY29kZSAke2NvZGV9OiAke0J1ZmZlci5jb25jYXQoc3RkZXJyKS50b1N0cmluZygndXRmLTgnKS50cmltKCl9YCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxubGV0IGJ1Y2tldHNUb0RlbGV0ZSA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbi8qKlxuICogQXBwZW5kIHRoaXMgdG8gdGhlIGxpc3Qgb2YgYnVja2V0cyB0byBwb3RlbnRpYWxseSBkZWxldGVcbiAqXG4gKiBBdCB0aGUgZW5kIG9mIGEgdGVzdCwgd2UgY2xlYW4gdXAgYnVja2V0cyB0aGF0IG1heSBub3QgaGF2ZSBnb3R0ZW4gZGVzdHJveWVkXG4gKiAoZm9yIHdoYXRldmVyIHJlYXNvbikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1lbWJlclRvRGVsZXRlQnVja2V0KGJ1Y2tldE5hbWU6IHN0cmluZykge1xuICBidWNrZXRzVG9EZWxldGUucHVzaChidWNrZXROYW1lKTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lZDxBPih4OiBBKTogeCBpcyBOb25OdWxsYWJsZTxBPiB7XG4gIHJldHVybiB4ICE9PSB1bmRlZmluZWQ7XG59Il19